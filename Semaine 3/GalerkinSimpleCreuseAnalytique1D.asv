% Paramètres
N = 10;                 % Nombre de fonctions de base
beta = 2;             % Paramètre d'échelle

% Initialisation de la matrice H
H = zeros(N+1, N+1);


% Creation des diagonales de la matrice creuse H.
j = 2:N;
Diag1 = (1 - beta^4)/(4*beta^2) * sqrt(j*(j-1));

j = 

% Remplissage de H selon les formules analytiques
for j = 0:N
    for i = 0:N
        val = 0;

        if i == j-2
            val = (1 - beta^4)/(4*beta^2) * sqrt(j*(j-1));
        elseif i == j
            val = (1 - beta^4)/(4*beta^2)*(2*j + 1) + 0.5*beta^2*(1 + 2*j);
        elseif i == j+2
            val = (1 - beta^4)/(4*beta^2) * sqrt((j+1)*(j+2));
        end

        H(i+1,j+1) = val;  % +1 car MATLAB indexe à partir de 1
    end
end

% Diagonalisation
[V, D] = eig(H);
energies = diag(D);

% Affichage des énergies
fprintf('Valeurs propres (énergies) :\n');
disp(energies);

% % Optionnel : tracer les fonctions propres reconstruites
% x = linspace(-8, 8, 1000);
% phi = zeros(N+1, length(x));
% 
% % Construction des fonctions de base phi_n(x)
% for n = 0:N
%     Hn = hermiteH(n, beta*x);
%     phi(n+1, :) = exp(-(beta*x).^2 / 2) .* Hn ./ sqrt(beta*2^n * factorial(n) * sqrt(pi));
% end
% 
% % Tracer les 3 premières fonctions propres
% figure;
% for k = 1:3
%     psi = V(:,k)' * phi;
%     plot(x, psi, 'DisplayName', sprintf('n = %d, E = %.3f', k-1, energies(k)));
%     hold on;
% end
% legend;
% xlabel('x');
% ylabel('\psi(x)');
% title('Fonctions propres approx. par méthode de Galerkin');
% grid on;
