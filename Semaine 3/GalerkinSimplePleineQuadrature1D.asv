N = 20;              % nombre de fonctions de base
M = 100;             % nombre de points de quadrature
beta = 1;            % paramètre des Hermite généralisées

[x, w] = hermpts(M); % points et poids de Gauss-Hermite (nécessite Chebfun)

% Évaluation des fonctions de base
Phi = zeros(N, M);       % Phi(j, k) = phi_j(x_k)
d2Phi = zeros(N, M);     % deuxième dérivée

for j = 0:N-1
    Hn = hermiteH(j, beta*x);           % polynôme d’Hermite H_j(βx)
    d2Hn = hermiteH_double_prime(j, beta*x); % à implémenter ou approximer numériquement

    norm = 1 / sqrt(beta * 2^j * factorial(j) * sqrt(pi));
    expfac = exp(-(beta*x).^2 / 2);

    Phi(j+1, :) = norm * Hn .* expfac;
    d2Phi(j+1, :) = norm * expfac .* (beta^2 * d2Hn - beta^3 * 2 * x .* hermiteH_prime(j, beta*x) + beta^4 * (x.^2 - 1) .* Hn);
end

% Potentiel général (ex. harmonique)
Vx = 0.5 * x.^2;

% Calcul de Hφ_j(x_k)
Hphi = -0.5 * d2Phi + Vx' .* Phi;

% Construction de la matrice H_{ij}
H = Phi * diag(w) * Hphi';   % produit matriciel quadrature

% Diagonalisation
[Evec, Eval] = eig(H);
evals = diag(Eval);
